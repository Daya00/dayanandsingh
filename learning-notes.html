<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Frontend Learning Notes</title>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: Arial, sans-serif;
    }

    body {
      background: #f4f6f8;
    }

    /* ===== HEADER ===== */
    header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 60px;
      background: #111827;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 30px;
      z-index: 1000;
    }

    header button {
      background: none;
      border: none;
      color: #9ca3af;
      font-size: 16px;
      cursor: pointer;
      padding: 8px 14px;
      border-radius: 6px;
    }

    header button.active {
      background: #2563eb;
      color: white;
    }

    /* ===== MAIN CONTENT ===== */
    main {
      padding-top: 80px; /* space for fixed header */
      max-width: 1200px;
      margin: auto;
    }

    section {
      display: none;
      animation: fadeIn 0.3s ease-in;
    }

    section.active {
      display: block;
    }

    /* ===== PLACEHOLDER CONTAINER STYLE ===== */
    .unit-container {
      background: white;
      margin-bottom: 20px;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.05);
    }

    .unit-container h2 {
      color: #2563eb;
      margin-bottom: 10px;
    }

    .unit-container p {
      color: #374151;
      line-height: 1.6;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(5px); }
      to { opacity: 1; transform: translateY(0); }
    }

    body {
      font-family: "Segoe UI", sans-serif;
      background: linear-gradient(135deg, #eef2ff, #fdf2f8);
      padding: 30px;
    }

    .container {
      max-width: 900px;
      margin: auto;
    }

    h1 {
      text-align: center;
      background: linear-gradient(to right, #2563eb, #7c3aed);
      color: white;
      padding: 20px;
      border-radius: 14px;
      margin-bottom: 30px;
    }

    .card {
      background: white;
      border-radius: 16px;
      padding: 20px 25px;
      margin-bottom: 20px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.08);
    }

    .blue { border-left: 8px solid #2563eb; }
    .green { border-left: 8px solid #16a34a; }
    .orange { border-left: 8px solid #f97316; }
    .red { border-left: 8px solid #dc2626; }
    .purple { border-left: 8px solid #7c3aed; }

    h2 {
      margin-top: 0;
      color: #1f2937;
    }

    .flow {
      font-weight: bold;
      text-align: center;
      font-size: 18px;
      margin-top: 10px;
    }

    .tag {
      display: inline-block;
      background: #e0e7ff;
      color: #1e40af;
      padding: 5px 12px;
      border-radius: 999px;
      font-size: 14px;
      margin-right: 8px;
    }

    .table-wrapper {
  overflow-x: auto;
  margin-top: 15px;
}

.fancy-table {
  width: 100%;
  border-collapse: separate;
  border-spacing: 0;
  border-radius: 14px;
  overflow: hidden;
  font-size: 15px;
}

.fancy-table thead th {
  padding: 14px;
  color: white;
  text-align: center;
  font-weight: 600;
}

.fancy-table thead th:nth-child(1) {
  background: #334155;
}

.fancy-table thead th:nth-child(2) {
  background: linear-gradient(to right, #0ea5e9, #38bdf8);
}

.fancy-table thead th:nth-child(3) {
  background: linear-gradient(to right, #22c55e, #4ade80);
}

.fancy-table tbody td {
  padding: 14px;
  text-align: center;
  background: #f8fafc;
  border-bottom: 1px solid #e5e7eb;
  transition: all 0.25s ease;
}

.fancy-table tbody tr:hover td {
  background: #e0f2fe;
  transform: scale(1.01);
}

.fancy-table tbody td:first-child {
  font-weight: 600;
  background: #f1f5f9;
}

@media (max-width: 600px) {
  .fancy-table {
    font-size: 14px;
  }
}

pre {
  background: #1e1e1e;
  color: #d4d4d4;
  padding: 16px;
  border-radius: 10px;
  overflow-x: auto;
  font-size: 14px;
}

code {
  font-family: Consolas, Monaco, monospace;
}

  </style>
</head>

<body>

  <!-- ===== FIXED HEADER ===== -->
  <header>
    <button class="tab active" onclick="showSection('javascript')">JavaScript</button>
    <button class="tab" onclick="showSection('javascript_coding')">JavaScript Coding</button>
    <button class="tab" onclick="showSection('react')">React</button>
        <button class="tab" onclick="showSection('react_coding')">React Coding</button>

    <button class="tab" onclick="showSection('htmlcss')">HTML & CSS</button>
  </header>

  <!-- ===== MAIN AREA ===== -->
  <main>

    <!-- ===== JAVASCRIPT SECTION ===== -->
    <section id="javascript" class="active">
      <!-- Paste your 31 JavaScript containers here -->

      <div class="unit-container">
        <div class="container">

  <h1>ğŸ“¢ JavaScript Custom Events<br><small>(Easy & Interview-Ready)</small></h1>

  <!-- Step 1 -->
  <div class="card blue">
    <h2>1ï¸âƒ£ Create a Custom Event</h2>
    <p>
      ğŸ‘‰ Custom event banane ke liye <b>CustomEvent</b> constructor use hota hai
    </p>
    <pre>
const userLoggedIn = new CustomEvent("userLoggedIn", {
  detail: {
    userId: 101,
    name: "Dayanand"
  }
});
    </pre>
    <p>ğŸ“Œ <b>detail</b> â†’ Event ke sath data pass karne ke liye</p>
  </div>

  <!-- Step 2 -->
  <div class="card green">
    <h2>2ï¸âƒ£ Dispatch (Trigger) the Event</h2>
    <pre>
document.dispatchEvent(userLoggedIn);
    </pre>
    <p>ğŸ”” Event dispatch ho sakta hai:</p>
    <ul>
      <li>document</li>
      <li>window</li>
      <li>Any DOM element</li>
    </ul>
  </div>

  <!-- Step 3 -->
  <div class="card orange">
    <h2>3ï¸âƒ£ Listen to the Custom Event</h2>
    <pre>
document.addEventListener("userLoggedIn", (event) => {
  console.log("User Logged In:", event.detail);
});
    </pre>
    <p>âœ… Output:</p>
    <pre>
User Logged In: { userId: 101, name: "Dayanand" }
    </pre>
  </div>

  <!-- Step 4 -->
  <div class="card purple">
    <h2>4ï¸âƒ£ Real-World Example (Button â†’ App Event)</h2>
    <p>ğŸ”˜ Button fires custom event</p>
    <pre>
<button id="loginBtn">Login</button>

document.getElementById("loginBtn")
  .addEventListener("click", () => {
    const loginEvent = new CustomEvent("loginSuccess", {
      detail: { role: "Admin" }
    });

    window.dispatchEvent(loginEvent);
});
    </pre>

    <p>ğŸ“¢ App listens to it</p>
    <pre>
window.addEventListener("loginSuccess", (e) => {
  console.log("Role:", e.detail.role);
});
    </pre>
  </div>

  <!-- Comparison -->
 <!-- Interactive Comparison Table -->
<div class="card blue">
  <h2>5ï¸âƒ£ Custom Event vs Normal Event (Interactive)</h2>

  <div class="table-wrapper">
    <table class="fancy-table">
      <thead>
        <tr>
          <th>âš™ï¸ Feature</th>
          <th>ğŸŒ Normal Event</th>
          <th>ğŸš€ Custom Event</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Who creates</td>
          <td>Browser</td>
          <td>You (Developer)</td>
        </tr>
        <tr>
          <td>Examples</td>
          <td>click, input</td>
          <td>userLoggedIn</td>
        </tr>
        <tr>
          <td>Data passing</td>
          <td>Limited</td>
          <td>detail object</td>
        </tr>
        <tr>
          <td>Use case</td>
          <td>UI interactions</td>
          <td>App / Module communication</td>
        </tr>
      </tbody>
    </table>
  </div>

  <p style="margin-top:12px;">
    ğŸ’¡ <b>Tip:</b> Custom Events are best when you want
    <b>decoupled communication</b> between modules.
  </p>
</div>


  <!-- Interview -->
  <div class="card red">
    <h2>6ï¸âƒ£ Why Interviewers Love This ğŸ˜</h2>
    <ul>
      <li>Micro-frontend communication</li>
      <li>Decoupling modules</li>
      <li>Global app notifications</li>
      <li>Analytics / logging</li>
      <li>Replacing prop drilling (non-React)</li>
    </ul>
  </div>

  <!-- One Line -->
  <div class="card green">
    <h2>7ï¸âƒ£ One-Line Interview Answer ğŸ¯</h2>
    <p>
      ğŸ‘‰ <b>
        Custom Events in JavaScript allow developers to define and dispatch their own events with custom data using CustomEvent, enabling decoupled and scalable communication between components.
      </b>
    </p>
    <div>
      <span class="tag">Interview</span>
      <span class="tag">JavaScript</span>
      <span class="tag">CustomEvent</span>
    </div>
  </div>

</div>

<div class="container">

  <h1>ğŸ§  JavaScript Prototype<br><small>(Easy Explanation)</small></h1>

  <!-- What is Prototype -->
  <div class="card blue">
    <h2>ğŸ”µ What is a Prototype?</h2>
    <p>
      ğŸ‘‰ Prototype ek <b>backup object</b> hota hai<br>
      ğŸ‘‰ Jab object me property / method nahi milti, JavaScript prototype me dekhta hai
    </p>
    <p>ğŸ§  <i>â€œAgar yaha nahi mila, parent se puch loâ€</i></p>
  </div>

  <!-- Example -->
  <div class="card green">
    <h2>ğŸŸ¢ Simple Example</h2>
    <pre>
let person = {
  name: "Rahul"
};

console.log(person.toString());
    </pre>
    <p>â“ <b>toString()</b> person ke andar hai? âŒ</p>
    <p>âœ”ï¸ JavaScript ne prototype me dhunda</p>
  </div>

  <!-- Prototype Chain -->
  <div class="card orange">
    <h2>ğŸ§¬ Prototype Chain</h2>
    <div class="flow">
      person âœ person.__proto__ âœ Object.prototype âœ null
    </div>
    <p style="text-align:center;">ğŸ“Œ Is process ko kehte hain <b>Prototype Chain</b></p>
  </div>

  <!-- How it works -->
  <div class="card purple">
    <h2>ğŸŸ¡ How it Works (Steps)</h2>
    <ol>
      <li>JavaScript object ke andar dekhta hai</li>
      <li>Nahi mila â†’ prototype me</li>
      <li>Next prototype me check</li>
      <li>Mil gaya ya <b>null</b> â†’ stop</li>
    </ol>
  </div>

  <!-- Interview Trap -->
  <div class="card red">
    <h2>ğŸ”´ Interview Trap</h2>
    <p>âŒ Prototype = Copy</p>
    <p>âœ… Prototype = <b>Shared Reference</b></p>
  </div>

  <!-- One Line -->
  <div class="card blue">
    <h2>ğŸ¯ One-Line Interview Answer</h2>
    <p>
      ğŸ‘‰ <b>Prototype is a hidden object that allows JavaScript objects to share properties and methods.</b>
    </p>
    <div>
      <span class="tag">Interview</span>
      <span class="tag">JavaScript</span>
      <span class="tag">Prototype</span>
    </div>
  </div>

</div>

<div class="container">

  <h1>â³ Debouncing in JavaScript & React<br><small>(Easy + Interview Friendly)</small></h1>

  <!-- Problem -->
  <div class="card red">
    <h2>ğŸ” Problem samjho pehle</h2>
    <p>Socho tum search box me type kar rahe ho:</p>
    <pre>
r â†’ re â†’ rea â†’ reac â†’ react
    </pre>
    <ul>
      <li>âŒ Har key press par API call</li>
      <li>âŒ Too many API calls</li>
      <li>âŒ Slow app</li>
    </ul>
  </div>

  <!-- What is Debounce -->
  <div class="card green">
    <h2>âœ… Debouncing kya karta hai?</h2>
    <p>
      <b>Debouncing = Thoda ruk kar kaam karna</b><br>
      Jab user typing band karta hai (kuch time ke liye),
      tab sirf <b>ek baar</b> function run hota hai
    </p>
    <p>ğŸ“Œ Example:</p>
    <pre>
"User ne 500ms tak kuch type nahi kiya â†’ ab API call karo"
    </pre>
  </div>

  <!-- Real Life -->
  <div class="card blue">
    <h2>ğŸ§  Real Life Example</h2>
    <p>ğŸ”” <b>Lift ka button</b></p>
    <ul>
      <li>Tum button dabaate jaate ho</li>
      <li>Lift rukti nahi, wait karti hai</li>
      <li>Jab sab ruk jaate hain â†’ lift chalti hai</li>
    </ul>
    <p>â¡ï¸ <b>SAME = Debouncing</b></p>
  </div>

  <!-- Without Debounce -->
  <div class="card red">
    <h2>âŒ Without Debounce</h2>
    <pre>
function searchApi(text) {
  console.log("API call for:", text);
}
    </pre>
    <p>ğŸ‘‰ Har key press par API call ho jaayega</p>
  </div>

  <!-- Debounce Function -->
  <div class="card purple">
    <h2>ğŸ§© Debounce Function (Easy Version)</h2>
    <pre>
function debounce(fn, delay) {
  let timer;

  return function (...args) {
    clearTimeout(timer);

    timer = setTimeout(() => {
      fn(...args);
    }, delay);
  };
}
    </pre>
  </div>

  <!-- Usage -->
  <div class="card green">
    <h2>ğŸ¯ Use Debounce</h2>
    <pre>
function searchApi(text) {
  console.log("API call for:", text);
}

const debouncedSearch = debounce(searchApi, 500);

// Imagine this runs on keyup
debouncedSearch("r");
debouncedSearch("re");
debouncedSearch("rea");
debouncedSearch("react");
    </pre>
    <p>
      ğŸ‘‰ Result: Sirf last value <b>"react"</b> ke liye API call hogi
      (500ms baad)
    </p>
  </div>

  <!-- Timeline -->
  <div class="card blue">
    <h2>ğŸ“Œ Timeline Samjho</h2>
    <pre>
Type r     â†’ wait
Type re    â†’ timer reset
Type rea   â†’ timer reset
Type react â†’ wait 500ms â†’ API CALL ğŸ”¥
    </pre>
  </div>

  <!-- React Example -->
  <div class="card purple">
    <h2>âš›ï¸ React Example (Interview Favorite)</h2>
    <pre>
const handleSearch = (e) => {
  console.log("API Call:", e.target.value);
};

const debouncedSearch = useCallback(
  debounce(handleSearch, 500),
  []
);

<input type="text" onChange={debouncedSearch} />
    </pre>
  </div>

  <!-- Comparison -->
  <div class="card orange">
    <h2>ğŸ†š Debounce vs Throttle (1 Line)</h2>
    <pre>
Debounce        | Throttle
Last action     | Fixed interval
Search input   | Scroll / Resize
    </pre>
  </div>

  <!-- One Line -->
  <div class="card green">
    <h2>ğŸ§  One-line Definition (Interview)</h2>
    <p>
      <b>
        Debouncing delays function execution until the user stops triggering the event for a specified time.
      </b>
    </p>
  </div>

  <!-- TypeScript -->
  <div class="card blue">
    <h2>ğŸŸ¦ TypeScript React Example</h2>
    <pre>
import React, { useCallback, useRef, type ChangeEvent } from "react";

const App: React.FC = () => {
  const timer = useRef<number | undefined>(undefined);

  const handleSearch = useCallback(
    (e: ChangeEvent<HTMLInputElement>) => {
      if (timer.current) {
        clearTimeout(timer.current);
      }

      const value = e.target.value;

      timer.current = window.setTimeout(() => {
        console.log("API Call for:", value);
      }, 500);
    },
    []
  );

  return (
    <input
      type="text"
      placeholder="Type here..."
      onChange={handleSearch}
    />
  );
};

export default App;
    </pre>
  </div>

  <!-- JS -->
  <div class="card blue">
    <h2>ğŸŸ¨ JavaScript React Example</h2>
    <pre>
import { useCallback, useRef } from "react";

function App() {
  const timer = useRef(null);

  const handleSearch = useCallback((e) => {
    clearTimeout(timer.current);
    const value = e.target.value;

    timer.current = setTimeout(() => {
      console.log("API Call:", value);
    }, 500);
  }, []);

  return <input onChange={handleSearch} />;
}
    </pre>
  </div>

  <!-- Interview Trap -->
  <div class="card red">
    <h2>âš ï¸ Classic React Interview Trap</h2>
    <p>
      âŒ Debounce = delay API only<br>
      âŒ Debounce = stop re-render
    </p>
    <p>
      âœ… Debounce controls <b>function execution</b><br>
      âœ… Re-render still depends on state / props
    </p>
  </div>

</div>

<div class="container">

  <h1>â³ Debouncing with API Search (React + TypeScript)<br>
    <small>Easy Explanation â€¢ Interview Ready</small>
  </h1>

  <!-- Intro -->
  <div class="card blue">
    <h2>ğŸ¯ What are we building?</h2>
    <ul>
      <li>API se users fetch karenge</li>
      <li>Search box se filter karenge</li>
      <li>Har keypress par filter âŒ</li>
      <li>Debounce ke saath filter âœ…</li>
    </ul>
    <p><b>Goal:</b> Better performance + clean React logic</p>
  </div>

  <!-- Imports -->
  <div class="card green">
    <h2>1ï¸âƒ£ Imports</h2>
    <pre>
import React, { useEffect, useState, type ChangeEvent } from "react";
    </pre>
    <ul>
      <li><b>React</b> â†’ JSX ke liye</li>
      <li><b>useState</b> â†’ data store karne ke liye</li>
      <li><b>useEffect</b> â†’ API call on mount</li>
      <li><b>ChangeEvent</b> â†’ TypeScript input type</li>
    </ul>
  </div>

  <!-- User Type -->
  <div class="card purple">
    <h2>2ï¸âƒ£ User Type (TypeScript)</h2>
    <pre>
interface User {
  id: number;
  firstName: string;
  lastName: string;
}
    </pre>
    <p>
      ğŸ‘‰ TypeScript ko batata hai ki
      <b>User object kaisa hoga</b>
    </p>
  </div>

  <!-- Debounce Function -->
  <div class="card orange">
    <h2>3ï¸âƒ£ Debounce Function</h2>
    <pre>
function debounce&lt;T extends (...args: any[]) =&gt; void&gt;(
  func: T,
  delay: number
) {
  let timer: number;

  return (...args: Parameters&lt;T&gt;) =&gt; {
    clearTimeout(timer);
    timer = setTimeout(() =&gt; func(...args), delay);
  };
}
    </pre>
    <ul>
      <li>â³ Function ko delay karta hai</li>
      <li>âŒ¨ï¸ User typing band kare â†’ tab chale</li>
      <li>âš¡ Performance improve hoti hai</li>
    </ul>

    <p>
      ğŸ“Œ Example: <br>
      Typing <b>John</b> â†’ function sirf <b>300ms baad</b> run hota hai
    </p>
  </div>

  <!-- State -->
  <div class="card green">
    <h2>4ï¸âƒ£ Component State</h2>
    <pre>
const [users, setUsers] = useState&lt;User[]&gt;([]);
const [search, setSearch] = useState("");
const [filtered, setFiltered] = useState&lt;User[]&gt;([]);
    </pre>
    <ul>
      <li><b>users</b> â†’ API se aaye sab users</li>
      <li><b>search</b> â†’ input box ka text</li>
      <li><b>filtered</b> â†’ jo UI me dikhana hai</li>
    </ul>
  </div>

  <!-- Fetch API -->
  <div class="card blue">
    <h2>5ï¸âƒ£ Fetch Users from API</h2>
    <pre>
useEffect(() => {
  fetch("https://dummyjson.com/users")
    .then((res) => res.json())
    .then((data) => {
      setUsers(data.users);
      setFiltered(data.users);
    })
    .catch(console.error);
}, []);
    </pre>

    <ul>
      <li>ğŸ“¡ API call sirf once (empty dependency)</li>
      <li>ğŸ“¦ users me full data store</li>
      <li>ğŸ‘€ filtered = initial display list</li>
    </ul>
  </div>

  <!-- Debounced Search -->
  <div class="card purple">
    <h2>6ï¸âƒ£ Debounced Search Logic</h2>
    <pre>
const handleSearch = debounce((query: string) => {
  const result = users.filter((user) =>
    `${user.firstName} ${user.lastName}`
      .toLowerCase()
      .includes(query.toLowerCase())
  );
  setFiltered(result);
}, 300);
    </pre>

    <ul>
      <li>ğŸ” firstName + lastName search</li>
      <li>ğŸ”¡ Case-insensitive</li>
      <li>â³ Runs after 300ms debounce</li>
    </ul>
  </div>

  <!-- Input Handler -->
  <div class="card orange">
    <h2>7ï¸âƒ£ Input Change Handler</h2>
    <pre>
const onChange = (e: ChangeEvent&lt;HTMLInputElement&gt;) => {
  const value = e.target.value;
  setSearch(value);
  handleSearch(value);
};
    </pre>
    <ul>
      <li>âŒ¨ï¸ User types</li>
      <li>ğŸ“ search state update</li>
      <li>â³ debounced search trigger</li>
    </ul>
  </div>

  <!-- Render -->
  <div class="card blue">
    <h2>8ï¸âƒ£ Render UI</h2>
    <pre>
<input
  type="text"
  placeholder="Search by first or last name"
  value={search}
  onChange={onChange}
/>

<ul>
  {filtered.map((user) => (
    <li key={user.id}>
      {user.firstName} {user.lastName}
    </li>
  ))}
</ul>
    </pre>

    <p>
      âœ” Input controlled component <br>
      âœ” List renders from <b>filtered</b> array <br>
      âœ” <code>key</code> is mandatory in React lists
    </p>
  </div>

  <!-- Flow -->
  <div class="card green">
    <h2>ğŸ” Flow (Easy to Remember)</h2>
    <pre>
User types
  â†“
Debounce (300ms)
  â†“
Filter users
  â†“
Update state
  â†“
UI re-render
    </pre>
  </div>

  <!-- Interview -->
  <div class="card red">
    <h2>âš ï¸ Interview Traps</h2>
    <ul>
      <li>âŒ Debounce = API delay only</li>
      <li>âŒ Debounce stops re-render</li>
      <li>âœ… Debounce controls function execution</li>
      <li>âœ… Re-render depends on state change</li>
    </ul>
  </div>

  <!-- One Line -->
  <div class="card green">
    <h2>ğŸ¯ One-Line Interview Answer</h2>
    <p>
      <b>
        Debouncing delays expensive operations like filtering or API calls
        until the user stops typing, improving performance and user experience.
      </b>
    </p>
  </div>

</div>

<div class="container">

  <!-- HEADER -->
  <div class="card blue">
    <h1>ğŸ” JavaScript Event Loop</h1>
  </div>

  <!-- SINGLE THREAD -->
  <div class="card green">
    <h2>âš ï¸ JavaScript is Single-Threaded</h2>
    <p>
      JavaScript can do <strong>ONLY ONE thing at a time</strong>.<br>
      Question: How does JS handle async tasks like setTimeout, API calls, Promises?<br>
      <strong>Answer: Event Loop</strong>
    </p>
  </div>

  <!-- MAIN PARTS -->
  <div class="card purple">
    <h2>ğŸ§© Main Parts (Easy Words)</h2>
    <ul>
      <li><b>Call Stack</b> â†’ Where JS executes code</li>
      <li><b>Web APIs</b> â†’ Browser handles async tasks (timer, fetch, DOM events)</li>
      <li><b>Microtask Queue</b> â†’ Promise.then, async/await</li>
      <li><b>Callback Queue</b> â†’ setTimeout, events</li>
      <li><b>Event Loop</b> â†’ Manager that moves tasks to Call Stack</li>
    </ul>
  </div>

  <!-- SIMPLE RULE -->
  <div class="card orange">
    <h2>â­ Simple Rule to Remember</h2>
    <p>
      1ï¸âƒ£ Call Stack executes first<br>
      2ï¸âƒ£ Microtask Queue (Promises)<br>
      3ï¸âƒ£ Callback Queue (setTimeout)
    </p>
  </div>

  <!-- EXAMPLE -->
  <div class="card blue">
    <h2>ğŸ’¡ Simple Example</h2>
    <pre>
console.log("Start");

setTimeout(() => {
  console.log("Timeout");
}, 0);

Promise.resolve().then(() => {
  console.log("Promise");
});

console.log("End");
    </pre>
  </div>

  <!-- OUTPUT -->
  <div class="card green">
    <h2>âœ… Output</h2>
    <pre>
Start
End
Promise
Timeout
    </pre>
  </div>

  <!-- STEP BY STEP -->
  <div class="card purple">
    <h2>ğŸ§  Step-by-Step Explanation</h2>

    <p><b>Step 1: Call Stack</b></p>
    <pre>
console.log("Start"); // printed
console.log("End");   // printed
â¡ Output so far:
Start
End
    </pre>

    <p><b>Step 2: Async Handling</b></p>
    <pre>
setTimeout â†’ Web API â†’ Callback Queue
Promise.then â†’ Microtask Queue
    </pre>

    <p><b>Step 3: Event Loop</b></p>
    <pre>
Call Stack empty âœ…
Microtask Queue first â†’ console.log("Promise")
Then Callback Queue â†’ console.log("Timeout")
    </pre>
  </div>

  <!-- VISUAL FLOW -->
  <div class="card orange">
    <h2>ğŸ”„ Visual Flow</h2>
    <pre>
Call Stack
   â†“
Microtask Queue (Promise)
   â†“
Callback Queue (setTimeout)
    </pre>
  </div>

  <!-- REAL LIFE -->
  <div class="card blue">
    <h2>ğŸ§‘â€ğŸ³ Real-Life Analogy</h2>
    <ul>
      <li>Chef â†’ JS Engine</li>
      <li>Orders â†’ Call Stack</li>
      <li>VIP Orders â†’ Microtask Queue (Promise)</li>
      <li>Timer Orders â†’ Callback Queue (setTimeout)</li>
    </ul>
    <p>
      Chef finishes current order â†’ Serves VIP first â†’ Then normal orders
    </p>
  </div>

  <!-- INTERVIEW ANSWER -->
  <div class="card green">
    <h2>ğŸ¯ One-Line Interview Answer</h2>
    <p>
      Event Loop continuously checks if Call Stack is empty, then executes microtasks first and macrotasks later to handle asynchronous JavaScript.
    </p>
  </div>

  <!-- IMPORTANT POINTS -->
  <div class="card purple">
    <h2>ğŸ“Œ Important Points (Exam + Interview)</h2>
    <ul>
      <li>âœ” JS is single-threaded</li>
      <li>âœ” Promises run before setTimeout</li>
      <li>âœ” Event Loop does not execute code, it only moves tasks</li>
    </ul>
  </div>

</div>

<div class="container">

  <!-- HEADER -->
  <div class="card blue">
    <h2>âš¡ TypeScript: any vs unknown vs never (Super Easy)</h2>
    <p>
      Simplest explanation + examples to remember for interviews and exams.
    </p>
  </div>

  <!-- ANY -->
  <div class="card green">
    <h2>1ï¸âƒ£ any</h2>
    <p>âŒ No type safety â†’ TypeScript stops checking types</p>
    <pre>
let a: any = 10;

a.toUpperCase();  // âœ… Allowed (may crash)
a();              // âœ… Allowed
    </pre>
    <ul>
      <li>âœ” Easy to use</li>
      <li>âŒ Unsafe</li>
      <li>âŒ Avoid in real projects</li>
    </ul>
  </div>

  <!-- UNKNOWN -->
  <div class="card purple">
    <h2>2ï¸âƒ£ unknown</h2>
    <p>âœ… Safe version of <code>any</code> â†’ TypeScript forces type checking</p>
    <pre>
let u: unknown = "hello";

// u.toUpperCase(); âŒ Error

if (typeof u === "string") {
  u.toUpperCase(); // âœ… Safe
}
    </pre>
    <ul>
      <li>âœ” Safe</li>
      <li>âœ” Recommended</li>
    </ul>
  </div>

  <!-- NEVER -->
  <div class="card orange">
    <h2>3ï¸âƒ£ never</h2>
    <p>ğŸš« Impossible value â†’ represents something that never happens</p>
    <pre>
function throwError(): never {
  throw new Error("Crash");
}

function infinite(): never {
  while (true) {}
}
    </pre>
    <ul>
      <li>âœ” Used for unreachable code</li>
      <li>âœ” Helps in exhaustive checks</li>
    </ul>
  </div>

  <!-- TABLE -->
 <!-- TABLE: any vs unknown vs never -->
<div class="card purple">
  <h2>ğŸ“Š TypeScript Types Comparison</h2>
   <div class="table-wrapper">
    <table class="fancy-table">
 
    <thead>
      <tr>
        <th>Type</th>
        <th>Meaning</th>
        <th>Can use directly?</th>
      </tr>
    </thead>
    <tbody>
      <tr >
        <td><b>any</b></td>
        <td>Anything allowed</td>
        <td>âœ… Yes</td>
      </tr>
      <tr>
        <td><b>unknown</b></td>
        <td>Anything, but check first</td>
        <td>âŒ No</td>
      </tr>
      <tr>
        <td><b>never</b></td>
        <td>Never happens</td>
        <td>ğŸš« No value</td>
      </tr>
    </tbody>
  </table>
   </div>
</div>


  <!-- REAL EXAMPLE -->
  <div class="card green">
    <h2>ğŸ§© Real Example (All Together)</h2>
    <pre>
function handle(value: unknown) {
  if (typeof value === "string") {
    console.log(value);      // value is string
  } else {
    const x: never = value; // unreachable case
  }
}
    </pre>
  </div>

  <!-- INTERVIEW ANSWER -->
  <div class="card purple">
    <h2>ğŸ¯ One-Line Interview Answer</h2>
    <p>
      <b>
        <code>any</code> disables type checking, <code>unknown</code> requires type checking, and <code>never</code> represents unreachable or impossible values.
      </b>
    </p>
  </div>

  <!-- MEMORY TRICK -->
  <div class="card orange">
    <h2>ğŸ§  Memory Trick</h2>
    <p>
      <strong>any â†’</strong> Do anything<br>
      <strong>unknown â†’</strong> Check first<br>
      <strong>never â†’</strong> Never happens
    </p>
  </div>

</div>


      </div>

    </section>

     <section id="javascript_coding" class="active">
      <!-- Paste your 31 JavaScript containers here -->

      <div class="unit-container">
      
    <div class="container">

      <h1>
        ğŸ“¢ Group Anagrams in JavaScript <br>
        <small>(Easy & Interview-Ready)</small>
      </h1>

      <!-- Step 1 -->
      <div class="card blue">
        <h3>ğŸŸ¦ </h3>
        <p>Create a function and an empty object to store anagram groups.</p>
        <pre><code>
function groupAnagrams(words) {
  const map = {};

  for (let word of words) {
    // Step 1: sort letters of word
    const sorted = word.split('').sort().join('');

    // Step 2: create group if not exists
    if (!map[sorted]) {
      map[sorted] = [];
    }

    // Step 3: push word into group
    map[sorted].push(word);
  }

  // Step 4: return all groups
  return Object.values(map);
}

// Example usage
const input = ["eat", "tea", "tan", "ate", "nat", "bat"];
console.log(groupAnagrams(input));

        </code></pre>
      </div>
   
    </div>

   
  <div class="container">

    <h2>ğŸ“Œ Second Largest Number in Array</h2>
    <p><strong>Here are two very simple ways ğŸ‘</strong><br>
      (Plain JavaScript, easy to remember)</p>

    <!-- Method 1 -->
    <div class="card blue">
      <h3>âœ… Method 1: Using loop <small>(BEST for interview)</small></h3>

      <pre><code>
const arr = [10, 5, 20, 8, 15];

let largest = -Infinity;
let secondLargest = -Infinity;

for (let num of arr) {
  if (num &gt; largest) {
    secondLargest = largest;
    largest = num;
  } else if (num &gt; secondLargest &amp;&amp; num !== largest) {
    secondLargest = num;
  }
}

console.log(secondLargest); // 15
      </code></pre>
    </div>

    <!-- Method 2 -->
    <div class="card green">
      <h3>âœ… Method 2: Using sort <small>(VERY simple)</small></h3>

      <pre><code>
const arr = [10, 5, 20, 8, 15];

const secondLargest = arr
  .sort((a, b) =&gt; b - a)[1];

console.log(secondLargest); // 15
      </code></pre>
    </div>

    <!-- Interview Tip -->
    <div class="card blue">
      <h3>ğŸ§  One-line Interview Answer</h3>
      <p>
        â€œTrack largest and second largest while looping through the array.â€
      </p>
    </div>

  </div>


  </div>

   

    </section>

    <!-- ===== REACT SECTION ===== -->
    <section id="react">
      <!-- Paste your 114 React containers here -->

      <div class="unit-container">
      
<div class="container">

  <h1>âš›ï¸ React Rendering<br><small>(Easy + Interview Focused)</small></h1>

  <!-- 1ï¸âƒ£ Analysis -->
  <div class="card green">
    <h2>1ï¸âƒ£ Analysis of Your Answer</h2>

    <p><b>âœ… What you got RIGHT</b></p>
    <ul>
      <li>âœ” React JSX is not HTML</li>
      <li>âœ” Code is bundled before going to browser</li>
      <li>âœ” Babel converts JSX to JavaScript</li>
      <li>âœ” Browser understands only JavaScript</li>
      <li>âœ” React UI is rendered after JS execution</li>
    </ul>

    <p><b>âš ï¸ What needs correction</b></p>
    <ul>
      <li>
        âŒ <b>Babel converts JSX to document.createElement</b><br>
        ğŸ‘‰ Babel converts JSX into <b>React.createElement()</b>, NOT document.createElement()
      </li>
      <li>
        âŒ <b>Old JS format</b><br>
        ğŸ‘‰ Babel transpiles JSX + modern JS into browser-compatible JavaScript
      </li>
      <li>
        âŒ <b>Missing Virtual DOM & ReactDOM</b><br>
        ğŸ‘‰ This is a BIG interview gap
      </li>
    </ul>
  </div>

  <!-- JSX Correction -->
  <div class="card red">
    <h2>âŒ Common JSX Misunderstanding</h2>

    <pre>
&lt;Daya /&gt;

â¬‡ Babel Output

React.createElement(Daya, null)
    </pre>

    <p>âš ï¸ React does <b>NOT</b> touch the real DOM at this stage</p>
  </div>

  <!-- Flow -->
  <div class="card blue">
    <h2>2ï¸âƒ£ Correct Flow: How React Renders</h2>

    <div class="flow">
      JSX â†’ React Elements â†’ Virtual DOM â†’ Real DOM â†’ Browser Paint
    </div>
  </div>

  <!-- Step by Step -->
  <div class="card purple">
    <h2>ğŸ§© Step-by-Step Rendering Process</h2>

    <ol>
      <li>
        <b>Write React Component</b>
        <pre>
function Daya() {
  return &lt;h1&gt;Hello Daya&lt;/h1&gt;;
}
        </pre>
      </li>

      <li>
        <b>Bundler (Webpack / Vite)</b>
        <p>Combines all JS into <code>bundle.js</code> (No DOM yet)</p>
      </li>

      <li>
        <b>Babel Transpilation</b>
        <pre>
function Daya() {
  return React.createElement("h1", null, "Hello Daya");
}
        </pre>
        <p>âš ï¸ Still JavaScript objects, not HTML</p>
      </li>

      <li>
        <b>Virtual DOM Creation</b>
        <pre>
{
  type: "h1",
  props: { children: "Hello Daya" }
}
        </pre>
      </li>

      <li>
        <b>ReactDOM Renders to Real DOM</b>
        <pre>
ReactDOM.createRoot(root).render(&lt;Daya /&gt;);
        </pre>
        <p>âœ” Uses <code>document.createElement</code> internally</p>
      </li>

      <li>
        <b>Browser Paint</b>
        <p>DOM updated â†’ Pixels painted â†’ ğŸ‰ UI visible</p>
      </li>
    </ol>
  </div>

  <!-- Interview Answer -->
  <div class="card green">
    <h2>3ï¸âƒ£ Interview-Ready Explanation ğŸ¤</h2>
    <p>
      React components do not render HTML directly.
      First, the code is bundled using tools like Webpack or Vite.
      Babel converts JSX into React.createElement calls.
      These create a Virtual DOM, which ReactDOM compares and updates efficiently.
      Finally, the browser paints the updated UI.
    </p>
  </div>

  <!-- One Line -->
  <div class="card blue">
    <h2>ğŸ§  One-Line Summary (Powerful)</h2>
    <div class="flow">
      JSX â†’ React Elements â†’ Virtual DOM â†’ Diffing â†’ Real DOM â†’ Browser Paint
    </div>
  </div>

  <!-- Re-render -->
  <div class="card orange">
    <h2>ğŸ” How Re-Rendering Works</h2>

    <p><b>Re-render</b> = React runs your component function again</p>

    <p><b>ğŸ”” When does re-render happen?</b></p>
    <ul>
      <li>State change (useState / setState)</li>
      <li>Props change</li>
      <li>Context value change</li>
    </ul>

    <p><b>ğŸ”„ What happens?</b></p>
    <ul>
      <li>Component function re-runs</li>
      <li>New Virtual DOM created</li>
      <li>Old vs new Virtual DOM diffing</li>
      <li>Only changed DOM nodes update</li>
    </ul>

    <p>âš ï¸ <b>Important:</b> Re-render â‰  DOM update</p>
  </div>

  <!-- Performance -->
  <div class="card purple">
    <h2>ğŸš€ Performance Tips</h2>
    <ul>
      <li><b>React.memo</b> â†’ Prevents unnecessary re-renders</li>
      <li><b>useMemo</b> â†’ Avoids expensive recalculation</li>
      <li><b>useCallback</b> â†’ Avoids function recreation</li>
    </ul>
  </div>

  <!-- Final Interview Line -->
  <div class="card green">
    <h2>ğŸ¯ One-Line Interview Answer</h2>
    <p>
      <b>
        React re-renders by re-executing the component, creating a new Virtual DOM,
        diffing it with the old one, and updating only the changed DOM nodes.
      </b>
    </p>

    <div>
      <span class="tag">Interview</span>
      <span class="tag">React</span>
      <span class="tag">Virtual DOM</span>
    </div>
  </div>

</div>

<div class="container">

  <!-- HEADER -->
  
    <h1>Higher Order Component (HOC)</h1>
   
 

  <!-- SIMPLE MEANING -->
  <div class="card green">
    <h3>Simple Meaning</h3>
    <p>
      Higher Order Component (HOC) ek function hota hai jo ek component
      ko input leta hai aur ek naya enhanced component return karta hai.
    </p>
    <p>
      
      Component â†’ function ke andar â†’ extra logic â†’ new component
    </p>
  </div>

  <!-- REAL LIFE EXAMPLE -->
  <div class="card blue">
    <h3>Real-life Example</h3>
    <p>
      Socho tumhare paas normal coffee hai â˜•<br>
      Tum usme milk + sugar add kar dete ho<br><br>

      Coffee = Original Component<br>
      Milk / Sugar = Extra Logic<br>
      Coffee Machine = HOC
    </p>
  </div>

  <!-- WHY HOC -->
  <div class="card green">
    <h3>Why Higher Order Component?</h3>
    <ul>
      <li>Same logic bar-bar likhne se bachata hai</li>
      <li>Code reusable banata hai</li>
      <li>Interview-friendly approach</li>
    </ul>
  </div>

  <!-- EXAMPLE INTRO -->
  <div class="card blue">
    <h3>Simple Example</h3>
    <p>
      Goal: Ek HOC banana jo kisi bhi component me counter logic add kare.
    </p>
  </div>

  <!-- HOC CODE -->
  <div class="card green">
    <h4>1ï¸âƒ£ Higher Order Component</h4>
    <pre><code>
function withCounter(WrappedComponent) {
  return function EnhancedComponent() {
    const [count, setCount] = React.useState(0);

    const increment = () => setCount(count + 1);

    return (
      &lt;WrappedComponent
        count={count}
        increment={increment}
      /&gt;
    );
  };
}
    </code></pre>
  </div>

  <!-- NORMAL COMPONENT -->
  <div class="card green">
    <h4>2ï¸âƒ£ Normal Component</h4>
    <pre><code>
function ClickCounter({ count, increment }) {
  return (
    &lt;button onClick={increment}&gt;
      Clicked {count} times
    &lt;/button&gt;
  );
}
    </code></pre>
  </div>

  <!-- WRAP WITH HOC -->
  <div class="card green">
    <h4>3ï¸âƒ£ Wrap Component with HOC</h4>
    <pre><code>
export default withCounter(ClickCounter);
    </code></pre>
  </div>

  <!-- FLOW -->
  <div class="card blue">
    <h3>Flow</h3>
    <pre><code>
ClickCounter
   â†“
withCounter(ClickCounter)
   â†“
Enhanced Component (with extra logic)
    </code></pre>
  </div>

  <!-- INTERVIEW LINE -->
  <div class="card green">
    <h3>Interview One-Liner</h3>
    <p>
      A Higher Order Component is a function that takes a component
      and returns a new component with additional functionality.
    </p>
  </div>

  <!-- NOTES -->
  <div class="card blue">
    <h3>Important Notes</h3>
    <ul>
      <li>HOC hooks ka replacement nahi hai</li>
      <li>Mostly older React codebase me use hota hai</li>
      <li>Today logic sharing ke liye Custom Hooks prefer kiye jaate hain</li>
    </ul>
  </div>

</div>


      </div>

    </section>

      <!-- ===== REACT CODING SECTION ===== -->
    <section id="react_coding">
      <!-- Paste your 114 React containers here -->

      <div class="unit-container">
          <div class="container">
 <h1>
        ğŸ“¢ React User List (API + Search)
      </h1>

      <!-- Step 1 -->
     <div class="card blue">
  <pre><code>
import React, { useEffect, useState } from "react";

// 1ï¸âƒ£ Define TypeScript type
type User = {
  id: number;
  name: string;
  email: string;
};

const UserList: React.FC = () => {
  // 2ï¸âƒ£ State for API data
  const [users, setUsers] = useState&lt;User[]&gt;([]);
  const [search, setSearch] = useState("");

  // 3ï¸âƒ£ API call
  useEffect(() =&gt; {
    fetch("https://jsonplaceholder.typicode.com/users")
      .then(res =&gt; res.json())
      .then(data =&gt; setUsers(data));
  }, []);

  // 4ï¸âƒ£ Filter logic
  const filteredUsers = users.filter(user =&gt;
    user.name.toLowerCase().includes(search.toLowerCase())
  );

  return (
    &lt;div&gt;
      &lt;h3&gt;User List&lt;/h3&gt;

      {/* 5ï¸âƒ£ Input box */}
      &lt;input
        type="text"
        placeholder="Search user..."
        value={search}
        onChange={e =&gt; setSearch(e.target.value)}
      /&gt;

      {/* 6ï¸âƒ£ Display list */}
      &lt;ul&gt;
        {filteredUsers.map(user =&gt; (
          &lt;li key={user.id}&gt;
            {user.name} - {user.email}
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
};

export default UserList;
  </code></pre>
</div>
</div>
 <div class="container">
 <h1>
        ğŸ“¢ React User List (Search + Pagination) 
      </h1>

     <div class="card blue">
  <h3>ğŸ“„ React User List (Search + Pagination)</h3>

  <pre><code class="language-tsx">
import React, { useEffect, useState } from "react";

type User = {
  id: number;
  name: string;
  email: string;
};

const ITEMS_PER_PAGE = 3;

const UserList: React.FC = () => {
  const [users, setUsers] = useState&lt;User[]&gt;([]);
  const [search, setSearch] = useState("");
  const [page, setPage] = useState(1);

  useEffect(() =&gt; {
    fetch("https://jsonplaceholder.typicode.com/users")
      .then(res =&gt; res.json())
      .then(data =&gt; setUsers(data));
  }, []);

  // Search filter
  const filteredUsers = users.filter(user =&gt;
    user.name.toLowerCase().includes(search.toLowerCase())
  );

  // Pagination logic
  const startIndex = (page - 1) * ITEMS_PER_PAGE;
  const paginatedUsers = filteredUsers.slice(
    startIndex,
    startIndex + ITEMS_PER_PAGE
  );

  const totalPages = Math.ceil(filteredUsers.length / ITEMS_PER_PAGE);

  return (
    &lt;div&gt;
      &lt;h3&gt;User List&lt;/h3&gt;

      &lt;input
        type="text"
        placeholder="Search user..."
        value={search}
        onChange={e =&gt; {
          setSearch(e.target.value);
          setPage(1);
        }}
      /&gt;

      &lt;ul&gt;
        {paginatedUsers.map(user =&gt; (
          &lt;li key={user.id}&gt;
            {user.name} - {user.email}
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;

      &lt;button
        disabled={page === 1}
        onClick={() =&gt; setPage(page - 1)}
      &gt;
        Previous
      &lt;/button&gt;

      &lt;span style={{ margin: "0 10px" }}&gt;
        Page {page} of {totalPages}
      &lt;/span&gt;

      &lt;button
        disabled={page === totalPages}
        onClick={() =&gt; setPage(page + 1)}
      &gt;
        Next
      &lt;/button&gt;
    &lt;/div&gt;
  );
};

export default UserList;
  </code></pre>
</div>

</div>
<div class="container">
 <h1>
        ğŸ“¢ React TO DO 
      </h1>

     <div class="card blue">
  <h3>ğŸ“„ React TO DO</h3>

  <pre>
<code>
import React, { useState } from &quot;react&quot;;

type Item = {
  id: number;
  text: string;
};

const TodoList: React.FC = () =&gt; {
  const [input, setInput] = useState(&quot;&quot;);
  const [items, setItems] = useState&lt;Item[]&gt;([]);
  const [editId, setEditId] = useState&lt;number | null&gt;(null);

  const handleAddOrUpdate = () =&gt; {
    if (!input.trim()) return;

    // Update existing item
    if (editId !== null) {
      setItems(
        items.map(item =&gt;
          item.id === editId ? { ...item, text: input } : item
        )
      );
      setEditId(null);
    } else {
      // Add new item
      setItems([...items, { id: Date.now(), text: input }]);
    }

    setInput(&quot;&quot;);
  };

  const handleEdit = (item: Item) =&gt; {
    setInput(item.text);
    setEditId(item.id);
  };

  const handleDelete = (id: number) =&gt; {
    setItems(items.filter(item =&gt; item.id !== id));
  };

  return (
    &lt;div&gt;
      &lt;h3&gt;Simple Add / Edit / Delete&lt;/h3&gt;

      &lt;input
        type=&quot;text&quot;
        placeholder=&quot;Enter value&quot;
        value={input}
        onChange={e =&gt; setInput(e.target.value)}
      /&gt;

      &lt;button onClick={handleAddOrUpdate}&gt;
        {editId ? &quot;Update&quot; : &quot;Add&quot;}
      &lt;/button&gt;

      &lt;ul&gt;
        {items.map(item =&gt; (
          &lt;li key={item.id}&gt;
            {item.text}

            &lt;button onClick={() =&gt; handleEdit(item)}&gt;Edit&lt;/button&gt;
            &lt;button onClick={() =&gt; handleDelete(item.id)}&gt;Delete&lt;/button&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
};

export default TodoList;
</code>
</pre>

</div>

</div>

<div class="container">
 <h1>
        ğŸ“¢ Multi API Call
      </h1>

     <div class="card blue">
  <h3>ğŸ“„ Multi API Call</h3>
<pre>
<code>
import React, { useEffect, useState } from &quot;react&quot;;
import axios from &quot;axios&quot;;

const MultiApiCall: React.FC = () =&gt; {
  const [users, setUsers] = useState&lt;any[]&gt;([]);
  const [posts, setPosts] = useState&lt;any[]&gt;([]);
  const [loading, setLoading] = useState(true);

  useEffect(() =&gt; {
    const headers = {
      Authorization: &quot;Bearer dummy-token&quot;,
      &quot;Content-Type&quot;: &quot;application/json&quot;,
    };

    // Call all APIs together
    Promise.all([
      axios.get(&quot;https://jsonplaceholder.typicode.com/users&quot;, { headers }),
      axios.get(&quot;https://jsonplaceholder.typicode.com/posts&quot;, { headers }),
    ])
      .then(([usersRes, postsRes]) =&gt; {
        setUsers(usersRes.data);
        setPosts(postsRes.data);
      })
      .catch(error =&gt; {
        console.error(&quot;API Error:&quot;, error);
      })
      .finally(() =&gt; {
        setLoading(false);
      });
  }, []);

  if (loading) return &lt;p&gt;Loading...&lt;/p&gt;;

  return (
    &lt;div&gt;
      &lt;h3&gt;Users&lt;/h3&gt;
      &lt;ul&gt;
        {users.slice(0, 3).map(user =&gt; (
          &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
        ))}
      &lt;/ul&gt;

      &lt;h3&gt;Posts&lt;/h3&gt;
      &lt;ul&gt;
        {posts.slice(0, 3).map(post =&gt; (
          &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
};

export default MultiApiCall;
</code>
</pre>


</div>

</div>

      </div>

    </section>

    <!-- ===== HTML & CSS SECTION ===== -->
    <section id="htmlcss">
      <!-- Paste HTML & CSS content here -->

      <div class="unit-container">
       
<div class="container">

  <h1>ğŸ·ï¸ Semantic Tags in HTML<br><small>(Easy Explanation)</small></h1>

  <!-- What are Semantic Tags -->
  <div class="card blue">
    <h2>ğŸ”µ What are Semantic Tags?</h2>
    <p>
      ğŸ‘‰ Semantic tags wo HTML tags hote hain jo <b>content ka meaning clearly batate hain</b><br>
      ğŸ‘‰ Ye sirf design nahi, balki <b>content ka purpose</b> batate hain
    </p>
    <p>ğŸ§  Browser aur developer dono samajh pate hain</p>
  </div>

  <!-- Common Semantic Tags -->
  <div class="card green">
    <h2>ğŸŸ¢ Common Semantic Tags</h2>
    <ul>
      <li><b>&lt;header&gt;</b> â€“ Top section (logo, title, menu)</li>
      <li><b>&lt;nav&gt;</b> â€“ Navigation links</li>
      <li><b>&lt;main&gt;</b> â€“ Main content of page</li>
      <li><b>&lt;section&gt;</b> â€“ Group of related content</li>
      <li><b>&lt;article&gt;</b> â€“ Independent content (blog, news)</li>
      <li><b>&lt;aside&gt;</b> â€“ Side content (ads, sidebar)</li>
      <li><b>&lt;footer&gt;</b> â€“ Bottom section (copyright, links)</li>
    </ul>
  </div>

  <!-- Example -->
  <div class="card orange">
    <h2>ğŸ§ª Simple Example</h2>
    <pre>
&lt;header&gt;
  &lt;h1&gt;My Website&lt;/h1&gt;
&lt;/header&gt;

&lt;nav&gt;
  &lt;a href="#"&gt;Home&lt;/a&gt;
&lt;/nav&gt;

&lt;main&gt;
  &lt;article&gt;
    &lt;h2&gt;Blog Title&lt;/h2&gt;
    &lt;p&gt;Blog content&lt;/p&gt;
  &lt;/article&gt;
&lt;/main&gt;

&lt;footer&gt;
  Â© 2025
&lt;/footer&gt;
    </pre>
  </div>

  <!-- Why use -->
  <div class="card purple">
    <h2>ğŸŸ¡ Why Use Semantic Tags?</h2>
    <ul>
      <li>âœ” Easy to understand code</li>
      <li>âœ” Better SEO</li>
      <li>âœ” Better accessibility (screen readers)</li>
    </ul>
  </div>

  <!-- Non semantic vs semantic -->
  <div class="card red">
    <h2>ğŸ”´ Non-Semantic vs Semantic</h2>
    <p>âŒ <b>&lt;div&gt;, &lt;span&gt;</b> â†’ No meaning</p>
    <p>âœ… <b>&lt;header&gt;, &lt;article&gt;</b> â†’ Clear meaning</p>
  </div>

  <!-- One Line -->
  <div class="card blue">
    <h2>ğŸ¯ One-Line Interview Answer</h2>
    <p>
      ğŸ‘‰ <b>Semantic tags describe the purpose of content in HTML clearly.</b>
    </p>
    <div>
      <span class="tag">HTML</span>
      <span class="tag">SEO</span>
      <span class="tag">Accessibility</span>
      <span class="tag">Interview</span>
    </div>
  </div>

</div>


      </div>

    </section>

  </main>

  <!-- ===== SCRIPT ===== -->
  <script>
    function showSection(sectionId) {
      const sections = document.querySelectorAll("section");
      const tabs = document.querySelectorAll(".tab");

      sections.forEach(section => {
        section.classList.remove("active");
      });

      tabs.forEach(tab => {
        tab.classList.remove("active");
      });

      document.getElementById(sectionId).classList.add("active");
      event.target.classList.add("active");
    }
  </script>

</body>
</html>
